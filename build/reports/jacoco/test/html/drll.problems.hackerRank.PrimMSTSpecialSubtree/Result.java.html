<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Result.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bacal</a> &gt; <a href="index.source.html" class="el_package">drll.problems.hackerRank.PrimMSTSpecialSubtree</a> &gt; <span class="el_source">Result.java</span></div><h1>Result.java</h1><pre class="source lang-java linenums">
package drll.problems.hackerRank.PrimMSTSpecialSubtree;

import java.util.*;

<span class="nc" id="L6">public class Result {</span>

    public static int prims(int n, List&lt;List&lt;Integer&gt;&gt; edges, int start) {
<span class="fc" id="L9">        int[] costs = initCosts(n + 1);</span>
<span class="fc" id="L10">        boolean[] visited = new boolean[n + 1];</span>
<span class="fc" id="L11">        List&lt;Integer&gt; mst = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L12">        HashMap&lt;Integer, List&lt;List&lt;Integer&gt;&gt;&gt; graph = buildGraph(edges);</span>

<span class="fc" id="L14">        costs[start] = 0;</span>
<span class="fc" id="L15">        visited[start] = true;</span>
<span class="fc" id="L16">        mst.add(start);</span>

<span class="fc bfc" id="L18" title="All 2 branches covered.">        while (mst.size() != n) {</span>

<span class="fc" id="L20">            int destination = 0;</span>
<span class="fc" id="L21">            int destinationWeight = Integer.MAX_VALUE;</span>

            /*
            * iterate over all nodes already in MST to find
            * the node not in MST with minimum weight that
            * is adjacent to a node in MST
            * */
<span class="fc bfc" id="L28" title="All 2 branches covered.">            for (int v : mst) {</span>

<span class="fc" id="L30">                List&lt;Integer&gt; adjacent = graph.get(v).get(0);</span>
<span class="fc" id="L31">                List&lt;Integer&gt; weights = graph.get(v).get(1);</span>

<span class="fc bfc" id="L33" title="All 2 branches covered.">                for (int j = 0, adjacentCount = adjacent.size(); j &lt; adjacentCount; j++) {</span>
<span class="fc" id="L34">                    Integer w = adjacent.get(j);</span>
<span class="fc bfc" id="L35" title="All 2 branches covered.">                    if (visited[w]) {</span>
<span class="fc" id="L36">                        continue;</span>
                    }
<span class="fc" id="L38">                    Integer wWeight = weights.get(j);</span>

<span class="fc" id="L40">                    updateCostsW(costs, w, wWeight);</span>

<span class="fc bfc" id="L42" title="All 2 branches covered.">                    if (wWeight &lt; destinationWeight) {</span>
<span class="fc" id="L43">                        destinationWeight = wWeight;</span>
<span class="fc" id="L44">                        destination = w;</span>
                    }
                }
<span class="fc" id="L47">            }</span>

<span class="fc" id="L49">            mst.add(destination);</span>
<span class="fc" id="L50">            visited[destination] = true;</span>
<span class="fc" id="L51">        }</span>

<span class="fc" id="L53">        return Arrays.stream(costs).sum();</span>
    }

    private static void updateCostsW(int[] costs, Integer w, Integer wWeight) {
<span class="fc bfc" id="L57" title="All 2 branches covered.">        if (wWeight &lt; costs[w]) {</span>
<span class="fc" id="L58">            costs[w] = wWeight;</span>
        }
<span class="fc" id="L60">    }</span>

    private static int[] initCosts(int n) {
<span class="fc" id="L63">        int[] costs = new int[n];</span>
<span class="fc" id="L64">        Arrays.fill(costs, 1, costs.length, (int) (Math.pow(10, 5) + 1));</span>
<span class="fc" id="L65">        return costs;</span>
    }

    private static HashMap&lt;Integer, List&lt;List&lt;Integer&gt;&gt;&gt; buildGraph(List&lt;List&lt;Integer&gt;&gt; edges) {
<span class="fc" id="L69">        HashMap&lt;Integer, List&lt;List&lt;Integer&gt;&gt;&gt; graph = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L71" title="All 2 branches covered.">        for (List&lt;Integer&gt; edge : edges) {</span>
<span class="fc" id="L72">            int v = edge.get(0);</span>
<span class="fc" id="L73">            int w = edge.get(1);</span>
<span class="fc" id="L74">            int weight = edge.get(2);</span>

<span class="fc" id="L76">            addEdge(graph, v, w, weight);</span>
<span class="fc" id="L77">            addEdge(graph, w, v, weight);</span>
<span class="fc" id="L78">        }</span>

<span class="fc" id="L80">        return graph;</span>
    }

    private static void addEdge(HashMap&lt;Integer, List&lt;List&lt;Integer&gt;&gt;&gt; graph, int v, int w, int weight) {
<span class="fc bfc" id="L84" title="All 2 branches covered.">        if (graph.containsKey(v)) {</span>
<span class="fc" id="L85">            graph.get(v).get(0).add(w);</span>
<span class="fc" id="L86">            graph.get(v).get(1).add(weight);</span>
        } else {
<span class="fc" id="L88">            List&lt;Integer&gt; adjacent = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L89">            adjacent.add(w);</span>
<span class="fc" id="L90">            List&lt;Integer&gt; weights = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L91">            weights.add(weight);</span>

<span class="fc" id="L93">            List&lt;List&lt;Integer&gt;&gt; neighbors = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L94">            neighbors.add(adjacent);</span>
<span class="fc" id="L95">            neighbors.add(weights);</span>

<span class="fc" id="L97">            graph.put(v, neighbors);</span>
        }
<span class="fc" id="L99">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>